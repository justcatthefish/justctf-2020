package main

import (
	"fmt"
	"io"
	fs "main/fs"
	"net/http"
	"os"
)

const FILE_MARKER = "\n\n~~~~~~~~~~~~~~ Generated by Go FileServ v0.0.0b ~~~~~~~~~~~~~\n\n(because writing file servers is eeaaassyyyy & fun!!!1111oneone)"
const VERSION = "FileServ v0.0.0b"

type wrapperW struct {
	http.ResponseWriter
}

func (w *wrapperW) ReadFrom(src io.Reader) (int64, error) {
	// if its a file, add the file marker length to its size
	if lr, ok := src.(*io.LimitedReader); ok {
		lr.N += int64(len(FILE_MARKER))
	}

	if w, ok := w.ResponseWriter.(interface{ ReadFrom(src io.Reader) (int64, error) }); ok {
		return w.ReadFrom(src)
	}

	panic("unreachable")
}

func main() {
	var path string
	if len(os.Args) < 2 {
		fmt.Println("Defaulting to serving current directory. Use ./fs <path> to serve different")
		path, _ = os.Getwd()
	} else {
		path = os.Args[1]
	}

	fileServ := http.FileServer(fs.CreateFileServFS(
		path,
		// Modify all responses by adding the file marker to them
		// we also need to adjust the file size in the ReadFrom because of to that...
		func(in []byte) (out []byte) {
			out = append(in, FILE_MARKER...)
			return
		}))

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Served-by", VERSION)
		w = &wrapperW{w}
		fileServ.ServeHTTP(w, r)
	})

	http.HandleFunc("/flag", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Served-by", VERSION)
		w.Write([]byte(`No flag for you!`))
	})

    port := "8080"
    fmt.Println("Hosting on port", port)
	err := http.ListenAndServe(":"+port, nil)
	fmt.Println(err)
}
